Acquiring state lock. This may take a few moments...

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
   +  create 
 [36m<=  read (data resources) 

Terraform will perform the following actions:

   # google_project_service.apis["aiplatform.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "aiplatform.googleapis.com"
    }

   # google_project_service.apis["artifactregistry.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "artifactregistry.googleapis.com"
    }

   # google_project_service.apis["cloudbilling.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "cloudbilling.googleapis.com"
    }

   # google_project_service.apis["cloudbuild.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "cloudbuild.googleapis.com"
    }

   # google_project_service.apis["cloudtrace.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "cloudtrace.googleapis.com"
    }

   # google_project_service.apis["compute.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "compute.googleapis.com"
    }

   # google_project_service.apis["dlp.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "dlp.googleapis.com"
    }

   # google_project_service.apis["firestore.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "firestore.googleapis.com"
    }

   # google_project_service.apis["logging.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "logging.googleapis.com"
    }

   # google_project_service.apis["monitoring.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "monitoring.googleapis.com"
    }

   # google_project_service.apis["redis.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "redis.googleapis.com"
    }

   # google_project_service.apis["run.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "run.googleapis.com"
    }

   # google_project_service.apis["secretmanager.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "secretmanager.googleapis.com"
    }

   # google_project_service.apis["servicenetworking.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "servicenetworking.googleapis.com"
    }

   # google_project_service.apis["sqladmin.googleapis.com"]  will be created
    +   resource "google_project_service" "apis" {
       +   disable_on_destroy = false
       +   id                 = (known after apply)
       +   project            = "project-id-12345"
       +   service            = "sqladmin.googleapis.com"
    }

   # google_secret_manager_secret.redis_password  will be created
    +   resource "google_secret_manager_secret" "redis_password" {
       +   create_time           = (known after apply)
       +   effective_annotations = (known after apply)
       +   effective_labels      = (known after apply)
       +   expire_time           = (known after apply)
       +   id                    = (known after apply)
       +   name                  = (known after apply)
       +   project               = "project-id-12345"
       +   secret_id             = "REDIS_PASSWORD"
       +   terraform_labels      = (known after apply)

       +   replication {
           +   auto {
            }
        }
    }

   # google_secret_manager_secret.stripe_publishable_key  will be created
    +   resource "google_secret_manager_secret" "stripe_publishable_key" {
       +   create_time           = (known after apply)
       +   effective_annotations = (known after apply)
       +   effective_labels      = (known after apply)
       +   expire_time           = (known after apply)
       +   id                    = (known after apply)
       +   name                  = (known after apply)
       +   project               = "project-id-12345"
       +   secret_id             = "STRIPE_PUBLISHABLE_KEY"
       +   terraform_labels      = (known after apply)

       +   replication {
           +   auto {
            }
        }
    }

   # google_secret_manager_secret.stripe_secret_key  will be created
    +   resource "google_secret_manager_secret" "stripe_secret_key" {
       +   create_time           = (known after apply)
       +   effective_annotations = (known after apply)
       +   effective_labels      = (known after apply)
       +   expire_time           = (known after apply)
       +   id                    = (known after apply)
       +   name                  = (known after apply)
       +   project               = "project-id-12345"
       +   secret_id             = "STRIPE_SECRET_KEY"
       +   terraform_labels      = (known after apply)

       +   replication {
           +   auto {
            }
        }
    }

   # google_secret_manager_secret_iam_member.backend_redis_password_access  will be created
    +   resource "google_secret_manager_secret_iam_member" "backend_redis_password_access" {
       +   etag      = (known after apply)
       +   id        = (known after apply)
       +   member    = (known after apply)
       +   project   = (known after apply)
       +   role      = "roles/secretmanager.secretAccessor"
       +   secret_id = (known after apply)
    }

   # google_secret_manager_secret_iam_member.frontend_stripe_publishable_key_access  will be created
    +   resource "google_secret_manager_secret_iam_member" "frontend_stripe_publishable_key_access" {
       +   etag      = (known after apply)
       +   id        = (known after apply)
       +   member    = (known after apply)
       +   project   = (known after apply)
       +   role      = "roles/secretmanager.secretAccessor"
       +   secret_id = (known after apply)
    }

   # google_secret_manager_secret_version.redis_password_version  will be created
    +   resource "google_secret_manager_secret_version" "redis_password_version" {
       +   create_time           = (known after apply)
       +   deletion_policy       = "DELETE"
       +   destroy_time          = (known after apply)
       +   enabled               = true
       +   id                    = (known after apply)
       +   is_secret_data_base64 = false
       +   name                  = (known after apply)
       +   secret                = (known after apply)
       +   secret_data           = (sensitive value)
       +   version               = (known after apply)
    }

   # module.billing_monitoring.google_billing_budget.budget  will be created
    +   resource "google_billing_budget" "budget" {
       +   billing_account = "11111111111111111"
       +   display_name    = "Monthly Budget - AI Platform"
       +   id              = (known after apply)
       +   name            = (known after apply)

       +   amount {
           +   specified_amount {
               +   currency_code = "USD"
               +   units         = "100"
            }
        }

       +   budget_filter {
           +   credit_types           = (known after apply)
           +   credit_types_treatment = "INCLUDE_ALL_CREDITS"
           +   labels                 = (known after apply)
           +   projects               = [
               +   "projects/project-id-12345",
            ]
           +   services               = (known after apply)
           +   subaccounts            = (known after apply)
        }

       +   threshold_rules {
           +   spend_basis       = "CURRENT_SPEND"
           +   threshold_percent = 0.5
        }
       +   threshold_rules {
           +   spend_basis       = "CURRENT_SPEND"
           +   threshold_percent = 0.9
        }
       +   threshold_rules {
           +   spend_basis       = "FORECASTED_SPEND"
           +   threshold_percent = 1
        }
    }

   # module.billing_monitoring.google_logging_metric.error_count  will be created
    +   resource "google_logging_metric" "error_count" {
       +   filter  = "resource.type=\"cloud_run_revision\" AND severity>=ERROR"
       +   id      = (known after apply)
       +   name    = "user/error_count"
       +   project = "project-id-12345"

       +   metric_descriptor {
           +   metric_kind = "DELTA"
           +   unit        = "1"
           +   value_type  = "INT64"
        }
    }

   # module.billing_monitoring.google_monitoring_alert_policy.anomaly_alert  will be created
    +   resource "google_monitoring_alert_policy" "anomaly_alert" {
       +   combiner              = "OR"
       +   creation_record       = (known after apply)
       +   display_name          = "AI Platform - Anomaly Detection"
       +   enabled               = true
       +   id                    = (known after apply)
       +   name                  = (known after apply)
       +   notification_channels = (known after apply)
       +   project               = "project-id-12345"

       +   conditions {
           +   display_name = "High Error Rate"
           +   name         = (known after apply)

           +   condition_threshold {
               +   comparison      = "COMPARISON_GT"
               +   duration        = "60s"
               +   filter          = "resource.type=\"cloud_run_revision\" AND metric.type=\"logging.googleapis.com/user/error_count\""
               +   threshold_value = 10

               +   aggregations {
                   +   alignment_period   = "60s"
                   +   per_series_aligner = "ALIGN_RATE"
                }
            }
        }
    }

   # module.billing_monitoring.google_monitoring_notification_channel.email  will be created
    +   resource "google_monitoring_notification_channel" "email" {
       +   display_name        = "Email Notification Channel"
       +   enabled             = true
       +   force_delete        = false
       +   id                  = (known after apply)
       +   labels              = {
           +   "email_address" = "user@gmail.com"
        }
       +   name                = (known after apply)
       +   project             = "project-id-12345"
       +   type                = "email"
       +   verification_status = (known after apply)
    }

   # module.cicd.google_artifact_registry_repository.repo  will be created
    +   resource "google_artifact_registry_repository" "repo" {
       +   create_time      = (known after apply)
       +   description      = "Docker repository for Cloud Run deployments"
       +   effective_labels = (known after apply)
       +   format           = "DOCKER"
       +   id               = (known after apply)
       +   location         = "us-central1"
       +   mode             = "STANDARD_REPOSITORY"
       +   name             = (known after apply)
       +   project          = "project-id-12345"
       +   repository_id    = "cloud-run-source-deploy"
       +   terraform_labels = (known after apply)
       +   update_time      = (known after apply)
    }

   # module.cicd.google_cloudbuild_trigger.backend  will be created
    +   resource "google_cloudbuild_trigger" "backend" {
       +   create_time    = (known after apply)
       +   description    = "Triggers build and deploy for Backend Agent on push to main"
       +   filename       = "cloudbuild-backend.yaml"
       +   id             = (known after apply)
       +   included_files = [
           +   "backend-agent/**",
           +   "cloudbuild-backend.yaml",
        ]
       +   location       = "global"
       +   name           = "backend-agent-trigger"
       +   project        = "project-id-12345"
       +   trigger_id     = (known after apply)

       +   approval_config (known after apply)

       +   github {
           +   name  = "my-ai-platform"
           +   owner = "RubensZimbres"

           +   push {
               +   branch = "^main$"
            }
        }
    }

   # module.cicd.google_cloudbuild_trigger.frontend  will be created
    +   resource "google_cloudbuild_trigger" "frontend" {
       +   create_time    = (known after apply)
       +   description    = "Triggers build and deploy for Frontend on push to main"
       +   filename       = "cloudbuild-frontend.yaml"
       +   id             = (known after apply)
       +   included_files = [
           +   "frontend-nextjs/**",
           +   "cloudbuild-frontend.yaml",
        ]
       +   location       = "global"
       +   name           = "frontend-nextjs-trigger"
       +   project        = "project-id-12345"
       +   trigger_id     = (known after apply)

       +   approval_config (known after apply)

       +   github {
           +   name  = "my-ai-platform"
           +   owner = "RubensZimbres"

           +   push {
               +   branch = "^main$"
            }
        }
    }

   # module.compute.data.google_project.project  will be read during apply
  # (depends on a resource or a module with changes pending)
  [36m<=   data "google_project" "project" {
       +   auto_create_network = (known after apply)
       +   billing_account     = (known after apply)
       +   deletion_policy     = (known after apply)
       +   effective_labels    = (known after apply)
       +   folder_id           = (known after apply)
       +   id                  = (known after apply)
       +   labels              = (known after apply)
       +   name                = (known after apply)
       +   number              = (known after apply)
       +   org_id              = (known after apply)
       +   skip_delete         = (known after apply)
       +   terraform_labels    = (known after apply)
    }

   # module.compute.google_cloud_run_v2_job.ingest_job  will be created
    +   resource "google_cloud_run_v2_job" "ingest_job" {
       +   conditions               = (known after apply)
       +   create_time              = (known after apply)
       +   creator                  = (known after apply)
       +   delete_time              = (known after apply)
       +   effective_annotations    = (known after apply)
       +   effective_labels         = (known after apply)
       +   etag                     = (known after apply)
       +   execution_count          = (known after apply)
       +   expire_time              = (known after apply)
       +   generation               = (known after apply)
       +   id                       = (known after apply)
       +   last_modifier            = (known after apply)
       +   latest_created_execution = (known after apply)
       +   launch_stage             = (known after apply)
       +   location                 = "us-central1"
       +   name                     = "ingest-job"
       +   observed_generation      = (known after apply)
       +   project                  = "project-id-12345"
       +   reconciling              = (known after apply)
       +   terminal_condition       = (known after apply)
       +   terraform_labels         = (known after apply)
       +   uid                      = (known after apply)
       +   update_time              = (known after apply)

       +   template {
           +   parallelism = (known after apply)
           +   task_count  = (known after apply)

           +   template {
               +   execution_environment = (known after apply)
               +   max_retries           = 3
               +   service_account       = (known after apply)
               +   timeout               = "600s"

               +   containers {
                   +   command = [
                       +   "python",
                       +   "ingest.py",
                    ]
                   +   image   = "us-docker.pkg.dev/cloudrun/container/hello"

                   +   env {
                       +   name  = "PROJECT_ID"
                       +   value = "project-id-12345"
                    }
                   +   env {
                       +   name  = "REGION"
                       +   value = "us-central1"
                    }
                   +   env {
                       +   name  = "DB_USER"
                       +   value = "postgres"
                    }
                   +   env {
                       +   name  = "DB_NAME"
                       +   value = "postgres"
                    }
                   +   env {
                       +   name  = "DB_HOST"
                       +   value = (known after apply)
                    }
                   +   env {
                       +   name = "DB_PASSWORD"

                       +   value_source {
                           +   secret_key_ref {
                               +   secret  = "project-id-12345-cloudsql-password"
                               +   version = "latest"
                            }
                        }
                    }
                   +   env {
                       +   name  = "REDIS_HOST"
                       +   value = (known after apply)
                    }

                   +   resources {
                       +   limits = {
                           +   "cpu"    = "2"
                           +   "memory" = "4Gi"
                        }
                    }
                }

               +   vpc_access {
                   +   egress = "ALL_TRAFFIC"

                   +   network_interfaces {
                       +   network    = "project-id-12345-vpc"
                       +   subnetwork = "project-id-12345-private-subnet"
                    }
                }
            }
        }
    }

   # module.compute.google_cloud_run_v2_service.backend  will be created
    +   resource "google_cloud_run_v2_service" "backend" {
       +   conditions              = (known after apply)
       +   create_time             = (known after apply)
       +   creator                 = (known after apply)
       +   delete_time             = (known after apply)
       +   effective_annotations   = (known after apply)
       +   effective_labels        = (known after apply)
       +   etag                    = (known after apply)
       +   expire_time             = (known after apply)
       +   generation              = (known after apply)
       +   id                      = (known after apply)
       +   ingress                 = "INGRESS_TRAFFIC_INTERNAL_ONLY"
       +   last_modifier           = (known after apply)
       +   latest_created_revision = (known after apply)
       +   latest_ready_revision   = (known after apply)
       +   launch_stage            = (known after apply)
       +   location                = "us-central1"
       +   name                    = "backend-agent"
       +   observed_generation     = (known after apply)
       +   project                 = "project-id-12345"
       +   reconciling             = (known after apply)
       +   terminal_condition      = (known after apply)
       +   terraform_labels        = (known after apply)
       +   traffic_statuses        = (known after apply)
       +   uid                     = (known after apply)
       +   update_time             = (known after apply)
       +   uri                     = (known after apply)

       +   template {
           +   max_instance_request_concurrency = (known after apply)
           +   service_account                  = (known after apply)
           +   timeout                          = "300s"

           +   containers {
               +   image = "us-docker.pkg.dev/cloudrun/container/hello"

               +   env {
                   +   name  = "PROJECT_ID"
                   +   value = "project-id-12345"
                }
               +   env {
                   +   name  = "REGION"
                   +   value = "us-central1"
                }
               +   env {
                   +   name  = "DB_USER"
                   +   value = "postgres"
                }
               +   env {
                   +   name  = "DB_NAME"
                   +   value = "postgres"
                }
               +   env {
                   +   name  = "DB_HOST"
                   +   value = (known after apply)
                }
               +   env {
                   +   name = "DB_PASSWORD"

                   +   value_source {
                       +   secret_key_ref {
                           +   secret  = "project-id-12345-cloudsql-password"
                           +   version = "latest"
                        }
                    }
                }
               +   env {
                   +   name  = "REDIS_HOST"
                   +   value = (known after apply)
                }

               +   liveness_probe {
                   +   failure_threshold     = 3
                   +   initial_delay_seconds = 30
                   +   period_seconds        = 15
                   +   timeout_seconds       = 3

                   +   http_get {
                       +   path = "/health"
                       +   port = 8080
                    }
                }

               +   ports (known after apply)

               +   resources {
                   +   limits = {
                       +   "cpu"    = "2"
                       +   "memory" = "4Gi"
                    }
                }

               +   startup_probe {
                   +   failure_threshold     = 3
                   +   initial_delay_seconds = 10
                   +   period_seconds        = 10
                   +   timeout_seconds       = 3

                   +   http_get {
                       +   path = "/health"
                       +   port = 8080
                    }
                }
            }

           +   scaling {
               +   max_instance_count = 20
               +   min_instance_count = 0
            }

           +   vpc_access {
               +   egress = "ALL_TRAFFIC"

               +   network_interfaces {
                   +   network    = "project-id-12345-vpc"
                   +   subnetwork = "project-id-12345-private-subnet"
                }
            }
        }

       +   traffic (known after apply)
    }

   # module.compute.google_cloud_run_v2_service.frontend  will be created
    +   resource "google_cloud_run_v2_service" "frontend" {
       +   conditions              = (known after apply)
       +   create_time             = (known after apply)
       +   creator                 = (known after apply)
       +   delete_time             = (known after apply)
       +   effective_annotations   = (known after apply)
       +   effective_labels        = (known after apply)
       +   etag                    = (known after apply)
       +   expire_time             = (known after apply)
       +   generation              = (known after apply)
       +   id                      = (known after apply)
       +   ingress                 = "INGRESS_TRAFFIC_ALL"
       +   last_modifier           = (known after apply)
       +   latest_created_revision = (known after apply)
       +   latest_ready_revision   = (known after apply)
       +   launch_stage            = (known after apply)
       +   location                = "us-central1"
       +   name                    = "frontend-agent"
       +   observed_generation     = (known after apply)
       +   project                 = "project-id-12345"
       +   reconciling             = (known after apply)
       +   terminal_condition      = (known after apply)
       +   terraform_labels        = (known after apply)
       +   traffic_statuses        = (known after apply)
       +   uid                     = (known after apply)
       +   update_time             = (known after apply)
       +   uri                     = (known after apply)

       +   template {
           +   max_instance_request_concurrency = (known after apply)
           +   service_account                  = (known after apply)
           +   timeout                          = "300s"

           +   containers {
               +   image = "us-docker.pkg.dev/cloudrun/container/hello"

               +   env {
                   +   name  = "BACKEND_URL"
                   +   value = (known after apply)
                }

               +   liveness_probe (known after apply)

               +   ports (known after apply)

               +   resources {
                   +   limits = {
                       +   "cpu"    = "1"
                       +   "memory" = "2Gi"
                    }
                }

               +   startup_probe (known after apply)
            }

           +   scaling {
               +   max_instance_count = 20
               +   min_instance_count = 0
            }

           +   vpc_access {
               +   egress = "ALL_TRAFFIC"

               +   network_interfaces {
                   +   network    = "project-id-12345-vpc"
                   +   subnetwork = "project-id-12345-private-subnet"
                }
            }
        }

       +   traffic (known after apply)
    }

   # module.compute.google_cloud_run_v2_service_iam_member.frontend_invokes_backend  will be created
    +   resource "google_cloud_run_v2_service_iam_member" "frontend_invokes_backend" {
       +   etag     = (known after apply)
       +   id       = (known after apply)
       +   location = "us-central1"
       +   member   = (known after apply)
       +   name     = "backend-agent"
       +   project  = (known after apply)
       +   role     = "roles/run.invoker"
    }

   # module.compute.google_cloud_run_v2_service_iam_member.public_invokes_frontend  will be created
    +   resource "google_cloud_run_v2_service_iam_member" "public_invokes_frontend" {
       +   etag     = (known after apply)
       +   id       = (known after apply)
       +   location = "us-central1"
       +   member   = "allUsers"
       +   name     = "frontend-agent"
       +   project  = (known after apply)
       +   role     = "roles/run.invoker"
    }

   # module.compute.google_project_iam_member.backend_cloudsql_client  will be created
    +   resource "google_project_iam_member" "backend_cloudsql_client" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/cloudsql.client"
    }

   # module.compute.google_project_iam_member.backend_dlp_user  will be created
    +   resource "google_project_iam_member" "backend_dlp_user" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/dlp.user"
    }

   # module.compute.google_project_iam_member.backend_firestore_user  will be created
    +   resource "google_project_iam_member" "backend_firestore_user" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/datastore.user"
    }

   # module.compute.google_project_iam_member.backend_trace_agent  will be created
    +   resource "google_project_iam_member" "backend_trace_agent" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/cloudtrace.agent"
    }

   # module.compute.google_project_iam_member.backend_vertex_user  will be created
    +   resource "google_project_iam_member" "backend_vertex_user" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/aiplatform.user"
    }

   # module.compute.google_secret_manager_secret_iam_member.backend_secret_access  will be created
    +   resource "google_secret_manager_secret_iam_member" "backend_secret_access" {
       +   etag      = (known after apply)
       +   id        = (known after apply)
       +   member    = (known after apply)
       +   project   = (known after apply)
       +   role      = "roles/secretmanager.secretAccessor"
       +   secret_id = "project-id-12345-cloudsql-password"
    }

   # module.compute.google_service_account.backend_sa  will be created
    +   resource "google_service_account" "backend_sa" {
       +   account_id   = "ai-backend-sa"
       +   disabled     = false
       +   display_name = "Backend Agent Service Account"
       +   email        = (known after apply)
       +   id           = (known after apply)
       +   member       = (known after apply)
       +   name         = (known after apply)
       +   project      = "project-id-12345"
       +   unique_id    = (known after apply)
    }

   # module.compute.google_service_account.frontend_sa  will be created
    +   resource "google_service_account" "frontend_sa" {
       +   account_id   = "ai-frontend-sa"
       +   disabled     = false
       +   display_name = "Frontend Agent Service Account"
       +   email        = (known after apply)
       +   id           = (known after apply)
       +   member       = (known after apply)
       +   name         = (known after apply)
       +   project      = "project-id-12345"
       +   unique_id    = (known after apply)
    }

   # module.database.google_firestore_backup_schedule.daily_backup  will be created
    +   resource "google_firestore_backup_schedule" "daily_backup" {
       +   database  = "(default)"
       +   id        = (known after apply)
       +   name      = (known after apply)
       +   project   = "project-id-12345"
       +   retention = "604800s"

       +   daily_recurrence {}
    }

   # module.database.google_firestore_database.firestore  will be created
    +   resource "google_firestore_database" "firestore" {
       +   app_engine_integration_mode       = (known after apply)
       +   concurrency_mode                  = "OPTIMISTIC"
       +   create_time                       = (known after apply)
       +   delete_protection_state           = "DELETE_PROTECTION_DISABLED"
       +   deletion_policy                   = "ABANDON"
       +   earliest_version_time             = (known after apply)
       +   etag                              = (known after apply)
       +   id                                = (known after apply)
       +   key_prefix                        = (known after apply)
       +   location_id                       = "us-central1"
       +   name                              = "(default)"
       +   point_in_time_recovery_enablement = "POINT_IN_TIME_RECOVERY_DISABLED"
       +   project                           = "project-id-12345"
       +   type                              = "FIRESTORE_NATIVE"
       +   uid                               = (known after apply)
       +   update_time                       = (known after apply)
       +   version_retention_period          = (known after apply)
    }

   # module.database.google_secret_manager_secret.db_pass_secret  will be created
    +   resource "google_secret_manager_secret" "db_pass_secret" {
       +   create_time           = (known after apply)
       +   effective_annotations = (known after apply)
       +   effective_labels      = (known after apply)
       +   expire_time           = (known after apply)
       +   id                    = (known after apply)
       +   name                  = (known after apply)
       +   project               = "project-id-12345"
       +   secret_id             = "project-id-12345-cloudsql-password"
       +   terraform_labels      = (known after apply)

       +   replication {
           +   user_managed {
               +   replicas {
                   +   location = "us-central1"
                }
            }
        }
    }

   # module.database.google_secret_manager_secret_version.db_pass_version  will be created
    +   resource "google_secret_manager_secret_version" "db_pass_version" {
       +   create_time           = (known after apply)
       +   deletion_policy       = "DELETE"
       +   destroy_time          = (known after apply)
       +   enabled               = true
       +   id                    = (known after apply)
       +   is_secret_data_base64 = false
       +   name                  = (known after apply)
       +   secret                = (known after apply)
       +   secret_data           = (sensitive value)
       +   version               = (known after apply)
    }

   # module.database.google_sql_database_instance.postgres  will be created
    +   resource "google_sql_database_instance" "postgres" {
       +   available_maintenance_versions = (known after apply)
       +   connection_name                = (known after apply)
       +   database_version               = "POSTGRES_15"
       +   deletion_protection            = true
       +   dns_name                       = (known after apply)
       +   encryption_key_name            = (known after apply)
       +   first_ip_address               = (known after apply)
       +   id                             = (known after apply)
       +   instance_type                  = (known after apply)
       +   ip_address                     = (known after apply)
       +   maintenance_version            = (known after apply)
       +   master_instance_name           = (known after apply)
       +   name                           = "project-id-12345-db"
       +   private_ip_address             = (known after apply)
       +   project                        = "project-id-12345"
       +   psc_service_attachment_link    = (known after apply)
       +   public_ip_address              = (known after apply)
       +   region                         = "us-central1"
       +   self_link                      = (known after apply)
       +   server_ca_cert                 = (sensitive value)
       +   service_account_email_address  = (known after apply)

       +   replica_configuration (known after apply)

       +   settings {
           +   activation_policy     = "ALWAYS"
           +   availability_type     = "ZONAL"
           +   connector_enforcement = (known after apply)
           +   disk_autoresize       = true
           +   disk_autoresize_limit = 0
           +   disk_size             = (known after apply)
           +   disk_type             = "PD_SSD"
           +   edition               = "ENTERPRISE"
           +   pricing_plan          = "PER_USE"
           +   tier                  = "db-g1-small"
           +   user_labels           = (known after apply)
           +   version               = (known after apply)

           +   backup_configuration {
               +   binary_log_enabled             = true
               +   enabled                        = true
               +   point_in_time_recovery_enabled = true
               +   start_time                     = "02:00"
               +   transaction_log_retention_days = (known after apply)

               +   backup_retention_settings {
                   +   retained_backups = 7
                   +   retention_unit   = "COUNT"
                }
            }

           +   insights_config (known after apply)

           +   ip_configuration {
               +   ipv4_enabled    = false
               +   private_network = (known after apply)
               +   server_ca_mode  = (known after apply)
               +   ssl_mode        = (known after apply)
            }

           +   location_preference (known after apply)
        }
    }

   # module.database.google_sql_user.users  will be created
    +   resource "google_sql_user" "users" {
       +   host                    = (known after apply)
       +   id                      = (known after apply)
       +   instance                = "project-id-12345-db"
       +   name                    = "postgres"
       +   password                = (sensitive value)
       +   project                 = "project-id-12345"
       +   sql_server_user_details = (known after apply)
    }

   # module.database.random_password.db_password  will be created
    +   resource "random_password" "db_password" {
       +   bcrypt_hash = (sensitive value)
       +   id          = (known after apply)
       +   length      = 16
       +   lower       = true
       +   min_lower   = 0
       +   min_numeric = 0
       +   min_special = 0
       +   min_upper   = 0
       +   number      = true
       +   numeric     = true
       +   result      = (sensitive value)
       +   special     = true
       +   upper       = true
    }

   # module.function.data.archive_file.source  will be read during apply
  # (depends on a resource or a module with changes pending)
  [36m<=   data "archive_file" "source" {
       +   id                  = (known after apply)
       +   output_base64sha256 = (known after apply)
       +   output_base64sha512 = (known after apply)
       +   output_md5          = (known after apply)
       +   output_path         = "/tmp/function-source.zip"
       +   output_sha          = (known after apply)
       +   output_sha256       = (known after apply)
       +   output_sha512       = (known after apply)
       +   output_size         = (known after apply)
       +   source_dir          = "./../functions/pdf-ingest"
       +   type                = "zip"
    }

   # module.function.google_cloudfunctions2_function.function  will be created
    +   resource "google_cloudfunctions2_function" "function" {
       +   description      = "Ingests PDFs into Vector DB on upload"
       +   effective_labels = (known after apply)
       +   environment      = (known after apply)
       +   id               = (known after apply)
       +   location         = "us-central1"
       +   name             = "pdf-ingest-function"
       +   project          = "project-id-12345"
       +   state            = (known after apply)
       +   terraform_labels = (known after apply)
       +   update_time      = (known after apply)
       +   url              = (known after apply)

       +   build_config {
           +   build                 = (known after apply)
           +   docker_repository     = (known after apply)
           +   entry_point           = "ingest_pdf"
           +   environment_variables = (known after apply)
           +   runtime               = "python311"
           +   service_account       = (known after apply)

           +   automatic_update_policy (known after apply)

           +   source {
               +   storage_source {
                   +   bucket     = (known after apply)
                   +   generation = (known after apply)
                   +   object     = (known after apply)
                }
            }
        }

       +   event_trigger {
           +   event_type            = "google.cloud.storage.object.v1.finalized"
           +   pubsub_topic          = (known after apply)
           +   retry_policy          = "RETRY_POLICY_RETRY"
           +   service_account_email = (known after apply)
           +   trigger               = (known after apply)
           +   trigger_region        = "us-central1"

           +   event_filters {
               +   attribute = "bucket"
               +   value     = (known after apply)
                [90m# (1 unchanged attribute hidden)  
            }
        }

       +   service_config {
           +   all_traffic_on_latest_revision   = true
           +   available_cpu                    = (known after apply)
           +   available_memory                 = "512M"
           +   environment_variables            = (known after apply)
           +   gcf_uri                          = (known after apply)
           +   ingress_settings                 = "ALLOW_ALL"
           +   max_instance_count               = 10
           +   max_instance_request_concurrency = (known after apply)
           +   service                          = (known after apply)
           +   service_account_email            = (known after apply)
           +   timeout_seconds                  = 300
           +   uri                              = (known after apply)

           +   secret_environment_variables {
               +   key        = "DB_PASSWORD"
               +   project_id = "project-id-12345"
               +   secret     = "project-id-12345-cloudsql-password"
               +   version    = "latest"
            }
        }
    }

   # module.function.google_project_iam_member.storage_viewer  will be created
    +   resource "google_project_iam_member" "storage_viewer" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/storage.objectViewer"
    }

   # module.function.google_project_iam_member.vertex_ai_user  will be created
    +   resource "google_project_iam_member" "vertex_ai_user" {
       +   etag    = (known after apply)
       +   id      = (known after apply)
       +   member  = (known after apply)
       +   project = "project-id-12345"
       +   role    = "roles/aiplatform.user"
    }

   # module.function.google_secret_manager_secret_iam_member.secret_access  will be created
    +   resource "google_secret_manager_secret_iam_member" "secret_access" {
       +   etag      = (known after apply)
       +   id        = (known after apply)
       +   member    = (known after apply)
       +   project   = (known after apply)
       +   role      = "roles/secretmanager.secretAccessor"
       +   secret_id = "project-id-12345-cloudsql-password"
    }

   # module.function.google_service_account.function_sa  will be created
    +   resource "google_service_account" "function_sa" {
       +   account_id   = "pdf-ingest-sa"
       +   disabled     = false
       +   display_name = "PDF Ingest Function SA"
       +   email        = (known after apply)
       +   id           = (known after apply)
       +   member       = (known after apply)
       +   name         = (known after apply)
       +   project      = "project-id-12345"
       +   unique_id    = (known after apply)
    }

   # module.function.google_storage_bucket_object.zip  will be created
    +   resource "google_storage_bucket_object" "zip" {
       +   bucket         = (known after apply)
       +   content        = (sensitive value)
       +   content_type   = "application/zip"
       +   crc32c         = (known after apply)
       +   detect_md5hash = "different hash"
       +   generation     = (known after apply)
       +   id             = (known after apply)
       +   kms_key_name   = (known after apply)
       +   md5hash        = (known after apply)
       +   media_link     = (known after apply)
       +   name           = (known after apply)
       +   output_name    = (known after apply)
       +   self_link      = (known after apply)
       +   source         = "/tmp/function-source.zip"
       +   storage_class  = (known after apply)
    }

   # module.ingress.google_compute_backend_service.default  will be created
    +   resource "google_compute_backend_service" "default" {
       +   connection_draining_timeout_sec = 300
       +   creation_timestamp              = (known after apply)
       +   enable_cdn                      = true
       +   fingerprint                     = (known after apply)
       +   generated_id                    = (known after apply)
       +   id                              = (known after apply)
       +   load_balancing_scheme           = "EXTERNAL"
       +   name                            = "project-id-12345-backend-service"
       +   port_name                       = "http"
       +   project                         = "project-id-12345"
       +   protocol                        = "HTTP"
       +   security_policy                 = (known after apply)
       +   self_link                       = (known after apply)
       +   session_affinity                = (known after apply)
       +   timeout_sec                     = 300

       +   backend {
           +   balancing_mode               = "UTILIZATION"
           +   capacity_scaler              = 1
           +   group                        = (known after apply)
           +   max_connections              = (known after apply)
           +   max_connections_per_endpoint = (known after apply)
           +   max_connections_per_instance = (known after apply)
           +   max_rate                     = (known after apply)
           +   max_rate_per_endpoint        = (known after apply)
           +   max_rate_per_instance        = (known after apply)
           +   max_utilization              = (known after apply)
            [90m# (1 unchanged attribute hidden)  
        }

       +   cdn_policy {
           +   cache_mode                   = "CACHE_ALL_STATIC"
           +   client_ttl                   = 3600
           +   default_ttl                  = 3600
           +   max_ttl                      = 86400
           +   negative_caching             = true
           +   serve_while_stale            = 86400
           +   signed_url_cache_max_age_sec = 3600

           +   cache_key_policy {
               +   include_host         = true
               +   include_protocol     = true
               +   include_query_string = true
            }
        }

       +   log_config (known after apply)
    }

   # module.ingress.google_compute_global_address.lb_ip  will be created
    +   resource "google_compute_global_address" "lb_ip" {
       +   address            = (known after apply)
       +   creation_timestamp = (known after apply)
       +   effective_labels   = (known after apply)
       +   id                 = (known after apply)
       +   label_fingerprint  = (known after apply)
       +   name               = "project-id-12345-lb-ip"
       +   prefix_length      = (known after apply)
       +   project            = "project-id-12345"
       +   self_link          = (known after apply)
       +   terraform_labels   = (known after apply)
    }

   # module.ingress.google_compute_global_forwarding_rule.default  will be created
    +   resource "google_compute_global_forwarding_rule" "default" {
       +   base_forwarding_rule  = (known after apply)
       +   effective_labels      = (known after apply)
       +   id                    = (known after apply)
       +   ip_address            = (known after apply)
       +   ip_protocol           = (known after apply)
       +   label_fingerprint     = (known after apply)
       +   load_balancing_scheme = "EXTERNAL"
       +   name                  = "project-id-12345-lb-forwarding-rule"
       +   network               = (known after apply)
       +   port_range            = "443"
       +   project               = "project-id-12345"
       +   psc_connection_id     = (known after apply)
       +   psc_connection_status = (known after apply)
       +   self_link             = (known after apply)
       +   subnetwork            = (known after apply)
       +   target                = (known after apply)
       +   terraform_labels      = (known after apply)

       +   service_directory_registrations (known after apply)
    }

   # module.ingress.google_compute_managed_ssl_certificate.default  will be created
    +   resource "google_compute_managed_ssl_certificate" "default" {
       +   certificate_id            = (known after apply)
       +   creation_timestamp        = (known after apply)
       +   expire_time               = (known after apply)
       +   id                        = (known after apply)
       +   name                      = "project-id-12345-ssl-cert"
       +   project                   = "project-id-12345"
       +   self_link                 = (known after apply)
       +   subject_alternative_names = (known after apply)
       +   type                      = "MANAGED"

       +   managed {
           +   domains = [
               +   "app.yourdomain.com",
            ]
        }
    }

   # module.ingress.google_compute_region_network_endpoint_group.serverless_neg  will be created
    +   resource "google_compute_region_network_endpoint_group" "serverless_neg" {
       +   id                    = (known after apply)
       +   name                  = "project-id-12345-frontend-neg"
       +   network_endpoint_type = "SERVERLESS"
       +   project               = "project-id-12345"
       +   region                = "us-central1"
       +   self_link             = (known after apply)

       +   cloud_run {
           +   service = "frontend-agent"
        }
    }

   # module.ingress.google_compute_security_policy.security_policy  will be created
    +   resource "google_compute_security_policy" "security_policy" {
       +   fingerprint = (known after apply)
       +   id          = (known after apply)
       +   name        = "project-id-12345-security-policy"
       +   project     = "project-id-12345"
       +   self_link   = (known after apply)
       +   type        = (known after apply)

       +   adaptive_protection_config {
           +   layer_7_ddos_defense_config {
               +   enable          = true
               +   rule_visibility = "STANDARD"
            }
        }

       +   advanced_options_config (known after apply)

       +   rule {
           +   action      = "allow"
           +   description = "Default allow rule"
           +   preview     = (known after apply)
           +   priority    = 2147483647

           +   match {
               +   versioned_expr = "SRC_IPS_V1"

               +   config {
                   +   src_ip_ranges = [
                       +   "*",
                    ]
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block Local File Inclusion"
           +   preview     = (known after apply)
           +   priority    = 1002

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('lfi-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block Protocol Attacks"
           +   preview     = (known after apply)
           +   priority    = 1004

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('protocolattack-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block Remote Command Execution"
           +   preview     = (known after apply)
           +   priority    = 1003

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('rce-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block SQL Injection"
           +   preview     = (known after apply)
           +   priority    = 1000

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('sqli-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block Scanner Detection"
           +   preview     = (known after apply)
           +   priority    = 1005

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('scannerdetection-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "deny(403)"
           +   description = "Block XSS"
           +   preview     = (known after apply)
           +   priority    = 1001

           +   match {
                [90m# (1 unchanged attribute hidden)  

               +   expr {
                   +   expression = "evaluatePreconfiguredExpr('xss-v33-stable')"
                }
            }
        }
       +   rule {
           +   action      = "rate_based_ban"
           +   description = "Rate limit to prevent abuse"
           +   preview     = (known after apply)
           +   priority    = 2000

           +   match {
               +   versioned_expr = "SRC_IPS_V1"

               +   config {
                   +   src_ip_ranges = [
                       +   "*",
                    ]
                }
            }

           +   rate_limit_options {
               +   ban_duration_sec    = 300
               +   conform_action      = "allow"
               +   enforce_on_key      = "IP"
               +   exceed_action       = "deny(429)"
                [90m# (1 unchanged attribute hidden)  

               +   rate_limit_threshold {
                   +   count        = 500
                   +   interval_sec = 60
                }
            }
        }
    }

   # module.ingress.google_compute_target_https_proxy.default  will be created
    +   resource "google_compute_target_https_proxy" "default" {
       +   creation_timestamp = (known after apply)
       +   id                 = (known after apply)
       +   name               = "project-id-12345-https-proxy"
       +   project            = "project-id-12345"
       +   proxy_bind         = (known after apply)
       +   proxy_id           = (known after apply)
       +   quic_override      = "NONE"
       +   self_link          = (known after apply)
       +   ssl_certificates   = (known after apply)
       +   tls_early_data     = (known after apply)
       +   url_map            = (known after apply)
    }

   # module.ingress.google_compute_url_map.default  will be created
    +   resource "google_compute_url_map" "default" {
       +   creation_timestamp = (known after apply)
       +   default_service    = (known after apply)
       +   fingerprint        = (known after apply)
       +   id                 = (known after apply)
       +   map_id             = (known after apply)
       +   name               = "project-id-12345-url-map"
       +   project            = "project-id-12345"
       +   self_link          = (known after apply)
    }

   # module.network.google_compute_global_address.private_ip_alloc  will be created
    +   resource "google_compute_global_address" "private_ip_alloc" {
       +   address            = (known after apply)
       +   address_type       = "INTERNAL"
       +   creation_timestamp = (known after apply)
       +   effective_labels   = (known after apply)
       +   id                 = (known after apply)
       +   label_fingerprint  = (known after apply)
       +   name               = "private-ip-alloc"
       +   network            = (known after apply)
       +   prefix_length      = 16
       +   project            = "project-id-12345"
       +   purpose            = "VPC_PEERING"
       +   self_link          = (known after apply)
       +   terraform_labels   = (known after apply)
    }

   # module.network.google_compute_network.vpc  will be created
    +   resource "google_compute_network" "vpc" {
       +   auto_create_subnetworks                   = false
       +   delete_default_routes_on_create           = false
       +   gateway_ipv4                              = (known after apply)
       +   id                                        = (known after apply)
       +   internal_ipv6_range                       = (known after apply)
       +   mtu                                       = (known after apply)
       +   name                                      = "project-id-12345-vpc"
       +   network_firewall_policy_enforcement_order = "AFTER_CLASSIC_FIREWALL"
       +   numeric_id                                = (known after apply)
       +   project                                   = "project-id-12345"
       +   routing_mode                              = "GLOBAL"
       +   self_link                                 = (known after apply)
    }

   # module.network.google_compute_router.router  will be created
    +   resource "google_compute_router" "router" {
       +   creation_timestamp = (known after apply)
       +   id                 = (known after apply)
       +   name               = "project-id-12345-router"
       +   network            = (known after apply)
       +   project            = "project-id-12345"
       +   region             = "us-central1"
       +   self_link          = (known after apply)
    }

   # module.network.google_compute_router_nat.nat  will be created
    +   resource "google_compute_router_nat" "nat" {
       +   auto_network_tier                   = (known after apply)
       +   enable_dynamic_port_allocation      = (known after apply)
       +   enable_endpoint_independent_mapping = (known after apply)
       +   endpoint_types                      = (known after apply)
       +   icmp_idle_timeout_sec               = 30
       +   id                                  = (known after apply)
       +   min_ports_per_vm                    = (known after apply)
       +   name                                = "project-id-12345-nat"
       +   nat_ip_allocate_option              = "AUTO_ONLY"
       +   project                             = "project-id-12345"
       +   region                              = "us-central1"
       +   router                              = "project-id-12345-router"
       +   source_subnetwork_ip_ranges_to_nat  = "ALL_SUBNETWORKS_ALL_IP_RANGES"
       +   tcp_established_idle_timeout_sec    = 1200
       +   tcp_time_wait_timeout_sec           = 120
       +   tcp_transitory_idle_timeout_sec     = 30
       +   udp_idle_timeout_sec                = 30
    }

   # module.network.google_compute_subnetwork.private_subnet  will be created
    +   resource "google_compute_subnetwork" "private_subnet" {
       +   creation_timestamp         = (known after apply)
       +   external_ipv6_prefix       = (known after apply)
       +   fingerprint                = (known after apply)
       +   gateway_address            = (known after apply)
       +   id                         = (known after apply)
       +   internal_ipv6_prefix       = (known after apply)
       +   ip_cidr_range              = "10.0.0.0/24"
       +   ipv6_cidr_range            = (known after apply)
       +   name                       = "project-id-12345-private-subnet"
       +   network                    = (known after apply)
       +   private_ip_google_access   = true
       +   private_ipv6_google_access = (known after apply)
       +   project                    = "project-id-12345"
       +   purpose                    = (known after apply)
       +   region                     = "us-central1"
       +   secondary_ip_range         = (known after apply)
       +   self_link                  = (known after apply)
       +   stack_type                 = (known after apply)
    }

   # module.network.google_service_networking_connection.default  will be created
    +   resource "google_service_networking_connection" "default" {
       +   id                      = (known after apply)
       +   network                 = (known after apply)
       +   peering                 = (known after apply)
       +   reserved_peering_ranges = [
           +   "private-ip-alloc",
        ]
       +   service                 = "servicenetworking.googleapis.com"
    }

   # module.redis.google_redis_instance.cache  will be created
    +   resource "google_redis_instance" "cache" {
       +   alternative_location_id  = (known after apply)
       +   auth_enabled             = true
       +   auth_string              = (sensitive value)
       +   authorized_network       = (known after apply)
       +   connect_mode             = "DIRECT_PEERING"
       +   create_time              = (known after apply)
       +   current_location_id      = (known after apply)
       +   display_name             = "AI Platform Cache"
       +   effective_labels         = (known after apply)
       +   host                     = (known after apply)
       +   id                       = (known after apply)
       +   location_id              = (known after apply)
       +   maintenance_schedule     = (known after apply)
       +   maintenance_version      = (known after apply)
       +   memory_size_gb           = 1
       +   name                     = "ai-cache"
       +   nodes                    = (known after apply)
       +   persistence_iam_identity = (known after apply)
       +   port                     = (known after apply)
       +   project                  = "project-id-12345"
       +   read_endpoint            = (known after apply)
       +   read_endpoint_port       = (known after apply)
       +   read_replicas_mode       = (known after apply)
       +   redis_version            = "REDIS_6_X"
       +   region                   = "us-central1"
       +   replica_count            = (known after apply)
       +   reserved_ip_range        = (known after apply)
       +   secondary_ip_range       = (known after apply)
       +   server_ca_certs          = (known after apply)
       +   terraform_labels         = (known after apply)
       +   tier                     = "BASIC"
       +   transit_encryption_mode  = "SERVER_AUTHENTICATION"

       +   persistence_config (known after apply)
    }

   # module.storage.google_storage_bucket.data_bucket  will be created
    +   resource "google_storage_bucket" "data_bucket" {
       +   effective_labels            = (known after apply)
       +   force_destroy               = true
       +   id                          = (known after apply)
       +   location                    = "US-CENTRAL1"
       +   name                        = (known after apply)
       +   project                     = (known after apply)
       +   project_number              = (known after apply)
       +   public_access_prevention    = (known after apply)
       +   rpo                         = (known after apply)
       +   self_link                   = (known after apply)
       +   storage_class               = "STANDARD"
       +   terraform_labels            = (known after apply)
       +   uniform_bucket_level_access = true
       +   url                         = (known after apply)

       +   lifecycle_rule {
           +   action {
               +   storage_class = "NEARLINE"
               +   type          = "SetStorageClass"
            }
           +   condition {
               +   days_since_noncurrent_time = 7
               +   matches_prefix             = []
               +   matches_storage_class      = []
               +   matches_suffix             = []
               +   num_newer_versions         = 1
               +   send_age_if_zero           = true
               +   with_state                 = (known after apply)
                [90m# (3 unchanged attributes hidden)  
            }
        }
       +   lifecycle_rule {
           +   action {
               +   storage_class = "ARCHIVE"
               +   type          = "SetStorageClass"
            }
           +   condition {
               +   days_since_noncurrent_time = 30
               +   matches_prefix             = []
               +   matches_storage_class      = []
               +   matches_suffix             = []
               +   num_newer_versions         = 1
               +   send_age_if_zero           = true
               +   with_state                 = (known after apply)
                [90m# (3 unchanged attributes hidden)  
            }
        }
       +   lifecycle_rule {
           +   action {
               +   type          = "Delete"
                [90m# (1 unchanged attribute hidden)  
            }
           +   condition {
               +   days_since_noncurrent_time = 90
               +   matches_prefix             = []
               +   matches_storage_class      = []
               +   matches_suffix             = []
               +   num_newer_versions         = 1
               +   send_age_if_zero           = true
               +   with_state                 = (known after apply)
                [90m# (3 unchanged attributes hidden)  
            }
        }

       +   soft_delete_policy (known after apply)

       +   versioning {
           +   enabled = true
        }

       +   website (known after apply)
    }

   # module.storage.google_storage_bucket.source_bucket  will be created
    +   resource "google_storage_bucket" "source_bucket" {
       +   effective_labels            = (known after apply)
       +   force_destroy               = true
       +   id                          = (known after apply)
       +   location                    = "US-CENTRAL1"
       +   name                        = (known after apply)
       +   project                     = (known after apply)
       +   project_number              = (known after apply)
       +   public_access_prevention    = (known after apply)
       +   rpo                         = (known after apply)
       +   self_link                   = (known after apply)
       +   storage_class               = "STANDARD"
       +   terraform_labels            = (known after apply)
       +   uniform_bucket_level_access = true
       +   url                         = (known after apply)

       +   soft_delete_policy (known after apply)

       +   versioning {
           +   enabled = true
        }

       +   website (known after apply)
    }

   # module.storage.random_id.bucket_suffix  will be created
    +   resource "random_id" "bucket_suffix" {
       +   b64_std     = (known after apply)
       +   b64_url     = (known after apply)
       +   byte_length = 4
       +   dec         = (known after apply)
       +   hex         = (known after apply)
       +   id          = (known after apply)
    }

 Plan:   72 to add, 0 to change, 0 to destroy.

Changes to Outputs:
   +   public_ip = (known after apply)
[90m
───────────────────────────────────────────────────────────────────────────── 

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
Releasing state lock. This may take a few moments...
